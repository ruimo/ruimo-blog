<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"/>
  <link rel="stylesheet" type="text/css" href="/stylesheet.css"/>
  <title>Surrogate key generation in VoltDB</title>
</head>
<body>
<h1>Surrogate key generation in VoltDB</h1>

<p style="text-align: right;"><a href="index.html">Japanese page</a></p>

<p>Just tried to implement surrogate key generation in VoltDB.</p>
<p>The test environment is as follows:</p>

<pre>
Ubuntu 10.04 64bit
Java: 1.6.0_20
Scala: 2.8.0
Core i7 875K(2.93GHz)
Memory: 8GB
VoltDB: voltdb-1.2.01
</pre>

<p>First of all, implement general hi-lo algorithm.</p>

<pre class="codeSample">
--- HighLowValue.scala ---
package com.ruimo.voltdb

private[voltdb] class HighLowValue(hiGenerator: HiGenerator, maxLowValue: Long) {
  val highValueFactor = maxLowValue + 1
  private var lowValue = highValueFactor
  private var highValue = 0L

  def reserve() = {
    if (lowValue &gt;= highValueFactor) obtainHighValue()
    if (Long.MaxValue / highValueFactor &lt; highValue)
      throw new HighValueOverflowException("High value = " + highValue + ", maxLowValue = " + maxLowValue)
    val ret = highValue * highValueFactor + lowValue
    lowValue = lowValue + 1
    ret
  }

  private def obtainHighValue() {
    highValue = hiGenerator.reserve()
    lowValue = 0
  }
}
</pre>

<p>Holding low value in memory, reserve() method increments it everytime the method is invoked. Once the low value exceeds the maxLowValue, obtain hi value by invoking hiGenerator.reserve(). Next, store this generator into thread local. In this way, every thread can have it's own surrogate key generator and create keys simultaneously.</p>

<pre class="codeSample">
package com.ruimo.voltdb

/**
 * Surrogate key generator. This is an implementation of traditional
 * hi-lo algorithm.
 * @author Shisei Hanai
 */
class IdentifierGenerator(
  hiGenerator: HiGenerator,
  maxLowValue: Long = IdentifierGenerator.DefaultMaxLowValue
) {
  import IdentifierGenerator._

  if (hiGenerator == null) throw new NullPointerException("hiGenerator is null")
  if (maxLowValue &lt;= 0) throw new IllegalArgumentException("maxLowValue should be positive integer.")

  /**
   * Reserve one identifier
   * @throws HighValueOverflowException Thrown if high value overflows.
   */
  def reserve(): Long = generatorInThreadLocal.reserve()

  private def generatorInThreadLocal = {
    var instance = repository.get
    if (instance == null) {
      instance = new HighLowValue(hiGenerator, maxLowValue)
      repository.set(instance)
    }
    instance
  }
}

object IdentifierGenerator {
  private val repository = new ThreadLocal[HighLowValue]

  /** Maximum low value of hi-lo method */
  val DefaultMaxLowValue = 31
}
</pre>

<p>The HiGenerator trait simply abstracts hi value generation:</p>

<pre class="codeSample">
--- HiGenerator.scala ---
package com.ruimo.voltdb

trait HiGenerator {
  def reserve(): Long
}
</pre>

<p>Now, the only remaining step is making VoltDB implementation of HiGenerator. Unfortunately, the current version of VoltDB does not support auto-increment column, create dedicated table for this purpose.</p>

<pre class="codeSample">
--- surrogatekey.sql ---
CREATE TABLE SurrogateKey (
  TableName VARCHAR(50) NOT NULL,    
  Id BIGINT NOT NULL,
  PRIMARY KEY (TableName)
);
</pre>

<p>Now, implement stored procedure to access this table:</p>

<pre class="codeSample">
---VoltDbHiGeneratorSp.scala ---
package com.ruimo.voltdb

import org.voltdb.ProcInfo
import org.voltdb.VoltProcedure
import org.voltdb.SQLStmt

@ProcInfo(
  singlePartition = true,
  partitionInfo = "SurrogateKey.TableName: 0"
)
class VoltDbHiGeneratorSp extends VoltProcedure {
  import TableNames._

  val QuerySql = new SQLStmt("select Id from " + SurrogateKey + " where TableName = ?;")
  val InsertSql = new SQLStmt("insert into " + SurrogateKey + " (TableName, Id) values (?, 1);")
  val UpdateSql = new SQLStmt("update " + SurrogateKey + " set Id = ? where TableName = ?;")

  def run(tableName: String): Long = {
    voltQueueSQL(QuerySql, tableName)
    val queryResult = voltExecuteSQL()(0)
    if (queryResult.getRowCount == 0) {
      insert(tableName)
      1
    }
    else {
      val id = queryResult.fetchRow(0).getLong(0) + 1
      update(id, tableName)
      id
    }
  }

  private def insert(tableName: String) {
    voltQueueSQL(InsertSql, tableName)
    voltExecuteSQL()
  }

  private def update(id: Long, tableName: String) {
    voltQueueSQL(UpdateSql, id.asInstanceOf[java.lang.Long], tableName)
    voltExecuteSQL()
  }
}
</pre>

<p>The run() method obtains current value by select statement. If there is no record found, insert a new record, otherwise update the value. In general, this code is not valid for most of RDB (unless transaction isolation level is set to most strict one) since another request can intervene between select and insert or update statement. However, in VoltDB, this is totally safe because a dedicated thread is prepared to work with every partition (consult section 1.3.2 of UsingVoltDB.pdf in detail).</p>

<p>To create module for server, prepare project.xml as follows:</p>

<pre class="codeSample">
--- project.xml ---
&lt;?xml version="1.0"?&gt;
&lt;project&gt;
  &lt;database name="database"&gt;
    &lt;schemas&gt;
      &lt;schema path="surrogatekey.sql"/&gt;
    &lt;/schemas&gt;
    &lt;procedures&gt;
      &lt;procedure class="com.ruimo.voltdb.VoltDbHiGeneratorSp"/&gt;
    &lt;/procedures&gt;
    &lt;partitions&gt;
      &lt;partition table="SurrogateKey" column="TableName"/&gt;
    &lt;/partitions&gt;
  &lt;/database&gt;
&lt;/project&gt;
</pre>

<p>Perform VoltDB compile to create server module.</p>

<pre class="codeSample">
java -cp voltdb-1.2.01.jar:scala-library.jar:classes org.voltdb.compiler.VoltCompiler project.xml voltDbSurrogateKey.jar
</pre>

<p>This will produce voltDbSurrogateKey.jar.</p>

<pre class="codeSample">
buildinfo.txt
catalog.txt
com/ruimo/voltdb/VoltDbHiGeneratorSp.class
project.xml
surrogatekey.sql
</pre>

<p>VoltDB compiler seems to extract only stored procedure classes and stores them into the jar file (perhaps it checks if @ProcInfo annotation is specified). Once the module is generated, prepare deployment configuration file:</p>

<pre class="codeSample">
--- deployment.xml ---
&lt;?xml version="1.0"?&gt;
&lt;deployment&gt;
  &lt;cluster hostcount="1"
           sitesperhost="2"
           leader="localhost"/&gt;
&lt;/deployment&gt;
</pre>

<p>As you can see, two partitions are configured. Now let's test the module. The following code is for calling the stored procedure, implemented above.</p>

<pre class="codeSample">
--- VoltDbHiGenerator.scala ---
package com.ruimo.voltdb

import org.voltdb._
import org.voltdb.client._
import scala.collection.JavaConversions._

/**
 * HiGenerator implementation using VoltDb.
 */
class VoltDbHiGenerator(client: Client, tableName: String) extends HiGenerator {
  if (client == null) throw new NullPointerException("client is null.")

  def reserve(): Long = {
    if (tableName == null) throw new NullPointerException("tableName is null.")

    val response = client.callProcedure("VoltDbHiGeneratorSp", tableName)
    if (response.getStatus != ClientResponse.SUCCESS) {
      throw new StoredProcedureError(response, "VoltDbHiGeneratorSp", tableName)
    }

    val results = response.getResults
    if (results.length == 0 || results(0).getRowCount() != 1) {
      throw new Error("VoltDbHiGeneratorSp did not return anything!")
    }

    results(0).fetchRow(0).getLong(0)
  }
}
</pre>

<p>The following code uses the helper class to generate surrogate keys.</p>

<pre class="codeSample">
--- Test.scala ---
import org.voltdb._
import org.voltdb.client._
import scala.collection.JavaConversions._
import com.ruimo.voltdb._

object Test {
  val result = new java.util.concurrent.ConcurrentHashMap[java.lang.Long, java.lang.Long]()

  class Worker extends java.util.concurrent.Callable[Long] {
    def call = {
      val client = ClientFactory.createClient()
      client.createConnection("localhost", "program", "password")

      try {
        run(client)
      }
      finally {
        client.close()
      }
    }

    private def run(client: Client): Long = {
      val start = System.currentTimeMillis
      var count = 10000
      val idGen = new IdentifierGenerator(new VoltDbHiGenerator(client, "Ruimo"))
      while (count &gt; 0) {
        val id = idGen.reserve()
        if (result.put(id, id) != null)
          throw new Error("Same id is generated! (id = " + id + ")")
        count = count - 1
      }

      System.currentTimeMillis - start
    }
  }

  def main(args: Array[String]) {
    val executor = java.util.concurrent.Executors.newFixedThreadPool(5)
    val resp: Iterable[java.util.concurrent.Future[Long]] =
      executor.invokeAll(java.util.Arrays.asList(new Worker(), new Worker(), new Worker(), new Worker(), new Worker()))
    resp.foreach {
      future =&gt; printf("Elapsed %,dms%n", future.get)
    }

    println(result.size)
    System.exit(0)
  }
}
</pre>

<p>As the CPU of test machine has four cores and hyper threading enabled, the test code creates five worker threads that invoke the store procedure simultaneously (each thread generats 10000 keys). All generated keys are stored in a Map to check the generated keys have no duplication. Using my test machine, the following result is obtained:</p>

<pre class="codeSample">
Elapsed 389ms
Elapsed 413ms
Elapsed 684ms
Elapsed 373ms
Elapsed 374ms
50000
</pre>

<p>As each thread takes about 400ms and 50000 keys are generated in total, it performs 125000 TPS in throughput perspective. As the test code specifies the same table name for every request, only one partition can be utilized. If you use the machine having the same spec as this machine (3GHz four cores and hyper threaded) and prepare 6 partitions, 6 times better performance should be easily achieved.</p>

<hr/>
<p>
  <a href="http://validator.w3.org/check?uri=referer">
    <img src="http://www.w3.org/Icons/valid-xhtml10"
         alt="Valid XHTML 1.0 Strict" height="31" width="88" />
  </a>
</p>
<p>Å@Mailto: <a href="mailto:ruimo@ruimo.uno.com">ruimo@ruimo.uno.com</a>
</p>
<p>Å@<a href="../..">To top page</a></p>
</body>
</html>
