<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  <title>Javaの部屋</title>
</head>
<body>
<h1>Javaの部屋</h1>
<p>Javaに関する気付いたことを書きためていきます。</p>
<p>cssのcounter機能を使用しているため、非対応ブラウザだと章番号が正しく表示されないかもしれません。</p>
<h2>目次</h2>
<p><a href="#mouseEvent1">マウスイベントの発生のしかた</a></p>
<p><a href="#mouseEvent2">マウスイベントの発生のしかた(2)</a></p>
<p><a href="#scrollpane">JScrollPaneでスクロールバーを共用する。</a></p>
<p><a href="#framework">典型的なマウスイベントの利用方法を設計してみる(未完成)</a></p>
<p><a href="#objectSize">オブジェクト1個で何バイト？</a></p>
<p><a href="javadoc-i18n/index.html">JavaDocでi18n</a></p>
<p><a href="midi/index.html">JavaでMIDI</a></p>
<p><a href="desktop/index.html">Javaデスクトップアプリケーション</a></p>

<h2>Swing</h2>
<h3 id="mouseEvent1">マウスイベントの発生のしかた</h3>
<p>色々なマウス操作をしてみてマウスイベントの発生のしかたを調査してみる。API仕様書で厳密に定義されているわけではないので、プラットフォームによるかもしれない。</p>
<h4>AからマウスカーソルをBを経由してCまで移動後、ボタンを押して離す。</h4>
<p>
<img src="fig001.png" style="float: left; margin: 2px 8px 2px 0px" alt="AからマウスカーソルをBを経由してCまで移動後、ボタンを押して離す。"/>
mouseEntered(B)<br/>
mouseMoved(B)<br/>
mouseMoved(BからCの間)<br/>
mouseMoved(C)<br/>
mousePressed(C)<br/>
mouseReleased(C)<br/>
mouseClicked(C)<br/>
<br style="clear: both"/>
</p>

<h4>Aでボタンを押し下げ、そのままBまで移動してボタンを離す。</h4>
<p>
<img src="fig002.png" style="float: margin: 2px 8px 2px 0px" alt="Aでボタンを押し下げ、そのままBまで移動してボタンを離す。"/>
mousePressed(A)<br/>
mouseDragged(A)<br/>
mouseDragged(AからBの間)<br/>
mouseDragged(B)<br/>
mouseReleased(B)<br/>
<br style="clear: both"/>
</p>

<h4>Aでボタンを押し下げ、そのままBを経由してCまで移動してボタンを離す。</h4>
<p>
<img src="fig003.png" style="float: left; margin: 2px 8px 2px 0px" alt="Aでボタンを押し下げ、そのままBを経由してCまで移動してボタンを離す。"/>
mousePressed(A)<br/>
mouseDragged(A)<br/>
mouseDragged(AからBの間)<br/>
mouseDragged(B)<br/>
mouseExited(B)<br/>
mouseDragged(BからCの間)<br/>
mouseReleased(C)<br/>
<br style="clear: both"/>
</p>
<h4>分かったこと</h4>
<ul>
<li>ドラッグの場合はウィンドウの外にマウスカーソルが出てしまってからもドラッグイベントが発生するようだ。</li>
<li>mousePressed()、mouseReleasedは押し下げ、押し上げで必ず発生するようだ。</li>
<li>mouseClicked()は、マウスカーソルを動かさずに押して離した時にだけ発生するようだ。タイミングはmouseReleased()の後。押した後動かすと、かわりにmouseDragged()が発生する。</li>
</ul>

<h3 id="mouseEvent2">マウスイベントの発生のしかた(2)</h3>
<p>InputEventには次のような定数定義がある。ALT_DOWN_MASK, ALT_GRAPH_DOWN_MASK, CTRL_DOWN_MASK, META_DOWN_MASK, SHIFT_DOWN_MASK。キーボードを押しながらクリックした時にどれが発生するのか。環境はWindows2000 J2SE5.0_04。MouseEvent.getModifierEx()を使用して調査。</p>
<pre>
    public void mouseClicked(MouseEvent e){
        StringBuffer modifier = new StringBuffer();
        if ((e.getModifiersEx() &amp; InputEvent.ALT_DOWN_MASK) != 0) {
            modifier.append("ALT, ");
        }
        if ((e.getModifiersEx() &amp; InputEvent.ALT_GRAPH_DOWN_MASK) != 0) {
            modifier.append("ALT_GRAPH, ");
        }
        if ((e.getModifiersEx() &amp; InputEvent.CTRL_DOWN_MASK) != 0) {
            modifier.append("CTRL, ");
        }
        if ((e.getModifiersEx() &amp; InputEvent.META_DOWN_MASK) != 0) {
            modifier.append("META, ");
        }
        if ((e.getModifiersEx() &amp; InputEvent.SHIFT_DOWN_MASK) != 0) {
            modifier.append("SHIFT, ");
        }
        if (modifier.length() >= 2)
            modifier.setLength(modifier.length() - 2);
        System.err.println("Mouse clicked (" + e.getX() + ", " + e.getY() + ") " +
                           e.getModifiersEx() + "(" + modifier + ")");
    }
</pre>
<table border="1">
  <tr><th>キー</th><th>発生イベント</th></tr>
  <tr><td>右、左Ctrl</td><td>CTRL_DOWN_MASK</td></tr>
  <tr><td>右、左Alt</td><td>ALT_DOWN_MASK</td></tr>
  <tr><td>右、左Shift</td><td>SHIFT_DOWN_MASK</td></tr>
</table>
<p>もちろん上記3つの任意のコンビネーション(同時押し)も検知される。上記以外のキー(ESC, 全角, CAPS, 無変換, 変換, かな)は影響を与えないようだ。</p>
<p>マウス右ボタンでMETA、マウス中央ボタンでALTが発生するようだ。これはキーボードと同時押しするとキーボードが優先される(例：SHIFT押しながら右クリックするとSHIFTのみが発生し、METAは付かない)。なんか不可思議な動きだ。中央ボタンはALTを押していようがいまいがALT付きで返ってくる。</p>
<p>ドラッグイベントはXXX_DOWN_MASKでは一切発生しない。かわりにMouseEvent.isShiftDown/isControlDown/isAltDownを使用する。イベントマスクを使用したいなら、SHIFT_MASK/CTRL_MASK/ALT_MASKを使う。非推奨になってるけど。これもなんか統一がとれていなくて妙な感じだ。</p>

<h3 id="scrollpane">JScrollPaneでスクロールバーを共用する。</h3>
<h4>水平スクロールバーを違う場所に表示して共用する。</h4>
<p><img src="fig008.png" style="float: left; margin: 2px 8px 2px 0px" alt="こんなUIを作りたい。"/>こんなUIを作りたい。JSplitPaneで複数に区切られた領域がJScrollPaneで提供されていて、水平方向のスクロールバーは1つにまとめたい。普通に作ると両方のJScrollPaneに別個の水平スクロールバーが表示されてしまう。</p>
<ul>
<li>JScrollPaneのhorizontalScrollBarPolicyはNEVERにする。<br/>
JScrollPane自身の水平スクロール表示をOFFにするため。
</li>
<li>上の領域のJScrollPaneのhorizontalScrollBarを取得して、好きな場所に表示する(今回はJSplitPaneの下)。<br/>
JScrollPaneのhorizontalScrollBarPolicyをNEVERにしていても、JScrollPaneは内部的にJScrollBarを生成しているので、このようなことが出来る。なおhorizontalScrollBarPolicyをNEVERにしないと、移動したつもりでもJScrollPaneのレイアウトマネージャが勝手に配置し直してしまうのでJScrollPaneの中に戻ってしまう。
</li>
<li>下の領域のhorizontalScrollBarに上の領域のhorizontalScrollBarの変更内容を転送してやる。</li>
</ul>
<p>
<br style="clear: both"/>
コード例(<a href="jscrollpane2.jar">ダウンロード(含ソース)</a>, <a href="jscrollpane2.jnlp">実行</a>)<br/>
</p>
<pre class="codeSample">
JScrollBar hscr1 = jScrollPane1.getHorizontalScrollBar();
hscr1.setVisible(true);
hscr1.addAdjustmentListener(new AdjustmentListener() {
    public void adjustmentValueChanged(AdjustmentEvent e) {
        jScrollPane2.getHorizontalScrollBar().setValue(e.getValue());
    }
});
getContentPane().add(hscr1, java.awt.BorderLayout.SOUTH);
</pre>

<p><img src="fig009.png" style="float: left; margin: 2px 8px 2px 0px" alt="水平スクロールバーが必ず表示されてしまう。"/>この方法だと水平スクロールバーが必ず出た状態になる。この方法の解決方法は次に述べる。
<br style="clear: both"/>
</p>

<h4>水平スクロールバーを必要な時にだけ表示したい。</h4>

<p><img src="fig010.png" style="float: left; margin: 2px 8px 2px 0px" alt="水平スクロールを必要な時だけ表示する。"/>
スクロールバーの最大値-最小値が、見えている領域サイズと等しいかどうかで、表示するかどうかを決定して、その都度visibleを制御。
<br style="clear: both"/>
コード例(<a href="jscrollpane3.jar">ダウンロード(含ソース)</a>, <a href="jscrollpane3.jnlp">実行</a>)</p>
<pre class="codeSample">
hscr1.addAdjustmentListener(new AdjustmentListener() {
    public void adjustmentValueChanged(AdjustmentEvent e) {
        jScrollPane2.getHorizontalScrollBar().setValue(e.getValue());

        JScrollBar sb = (JScrollBar)e.getSource();
        boolean needToShow = (sb.getMaximum() - sb.getMinimum() != sb.getVisibleAmount());
        if (needToShow != sb.isVisible()) {
            sb.setVisible(needToShow);
            sb.getParent().validate();
        }
    }
});
</pre>

<h4>垂直スクロールバーがある時と無い時でずれる。</h4>

<p><img src="fig011.png" style="float: left; margin: 2px 8px 2px 0px" alt="垂直スクロールバーのあり無しでずれる。"/>片方の領域に垂直スクロールバーがあって、もう片方には無い時、右端までスクロールすると、位置がずれてしまう(上下で桁位置が揃っていないことに注意)。これまで見てきた通り、水平スクロールは上の領域の所有だ。この表示例だと"2"が先頭になる位置に設定されている。その設定は下の領域にも適用されるが、そうすると右側に余白ができてしまうので、JScrollPaneがそのような表示を許さないようだ。
<br style="clear: both"/>
<img src="fig012.png" style="float: left; margin: 2px 8px 2px 0px" alt="無理やり書くと。"/>
レタッチして無理やり書くと、こんな感じか。JScrollPaneを継承、改造してこれを許すように頑張るという手もあるが、こんな表示をするために頑張ることに意味を見いだせなかった。
<br style="clear: both"/>
<img src="fig013.png" style="float: left; margin: 2px 8px 2px 0px" alt="PolicyをALWAYSに。"/>
安直な解決策1は垂直スクロールバーのpolicyをALWAYSにして常に表示させる方法。</p><p>あとは1つでも垂直スクロールバーが必要な領域が発生したら、全てに垂直スクロールバーを表示するというのもありかな。後者は、垂直スクロールバーを監視して実行時にpolicyを切り替えればできるはず。
<br style="clear: both"/>
</p>

<h4>オートスクロールができない。</h4>

<p>SwingではJComponent.setAutoscrolls()というメソッドがあって、これをtrueに設定してやると、コンポーネントから、そのコンポーネント外にマウスがドラッグされた時に合成イベントを生成してくれる(詳細は、JComponent.setAutoScrolls()のJavaDocを参照)。早速これを利用してみる。</p>
<ul>
<li>JScrollPaneの中のコンポーネントのautoScrollsプロパティをtrueに設定して、</li>
<li>コンポーネントにマウスドラッグイベント処理を追加する。</li>
</ul>
<p>コード例(<a href="jscrollpane4.jar">ダウンロード(含ソース)</a>, <a href="jscrollpane4.jnlp">実行</a>)</p>
<pre class="codeSample">
MouseMotionListener l = new MouseMotionAdapter() {
    public void mouseDragged(MouseEvent e) {
        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
        ((JLabel)e.getSource()).scrollRectToVisible(r);
    }
};

jLabel1.addMouseMotionListener(l);
jLabel2.addMouseMotionListener(l);
</pre>
<p><img src="fig014.png" style="float: left; margin: 2px 8px 2px 0px" alt="オートスクロール"/>
これによって、確かに上の領域に対してはオートスクロールがうまく動作する。領域内でマウスのボタンを押下して、そのまま領域外にドラッグすると、その方向にオートスクロールする。横にオートスクロールすれば、下の領域も一緒に追っかけてスクロールする。</p>
<p>しかし、下の領域のオートスクロールに対しては上は付いて込ない。これは考えてみれば当り前だ。上の領域の水平スクロールバーは監視されており、変化があれば下のスクロールバーに伝搬される。これに対し、下のスクロールバーの変化を上に伝える仕組みは無い。なので、単純に同様のコードを追加してみる。
<br style="clear: both"/></p>
<p>コード例(<a href="jscrollpane5.jar">ダウンロード(含ソース)</a>, <a href="jscrollpane5.jnlp">実行</a>)</p>
<pre class="codeSample">
JScrollBar hscr2 = jScrollPane2.getHorizontalScrollBar();
hscr2.addAdjustmentListener(new AdjustmentListener() {
    public void adjustmentValueChanged(AdjustmentEvent e) {
        jScrollPane1.getHorizontalScrollBar().setValue(e.getValue());
    }
});
</pre>
<p>一見、上のスクロールバーの変化が下のスクロールバーに伝えられ、それがまた上に伝えられ、と無限に続きそうだが、問題なく動作するようだ。恐らく値が同じ場合にはリスナが呼ばれないのだろう。</p>

<h3 id="framework">典型的なマウスイベントの利用方法を設計してみる(未完成)</h3>
<p>良くあるドロー系アプリケーションのようなマウスイベント処理を考えてみる。</p>
<h4>ユースケース</h4>
<p><img src="fig004.png" style="float: left; margin: 2px 8px 2px 0px" alt="ユースケース"/>
自由配置されたオブジェクトが複数存在。</p>
<p>オブジェクト上で左クリックした場合は、そのオブジェクトを選択状態とし、それ以外のオブジェクトを非選択状態とする。</p>
<p>オブジェクト上でSHIFTキーを押しながら左クリックした場合は、そのオブジェクトの選択状態を反転する(選択状態なら非選択状態に、非選択状態なら選択状態に変更)。すでに選択状態となっている他のオブジェクトの状態は変更しない。</p>
<p>オブジェクト以外の場所で左クリックした場合は、全てのオブジェクトの選択状態を解除する。</p>
<p>オブジェクト以外の場所でSHIFTキーを押しながら左クリックした場合は、何もしない。</p>
<p>オブジェクト上で右クリックした場合は、そのオブジェクトが選択状態の場合には、オブジェクト用の機能呼び出し(例：ポップアップメニュー表示)を全ての選択状態のオブジェクトに対して行う。右クリックしたオブジェクトが選択状態でなかった場合には、選択状態とし、他のオブジェクトの選択状態を解除し、右クリックされたオブジェクトに対してのみオブジェクト用の機能呼び出しを行う。</p>
<p>オブジェクト以外の場所で右クリックした場合は、全てのオブジェクトの選択状態を解除し、デフォルトの機能呼び出しを行う。</p>
<p>オブジェクトの上でドラッグを開始した場合、選択状態のオブジェクト全てを移動する。</p>
<p>オブジェクト以外の場所でドラッグを開始した場合、全てのオブジェクトの選択状態を解除し、枠線を描画する。ドラッグ終了時点で枠線内に領域が(一部でも)重なったオブジェクトを全て選択状態とする。</p>
<p>オブジェクト以外の場所でSHIFTキーを押しながらドラッグを開始した場合、枠線を描画する。ドラッグ終了時点で枠線内に領域が(一部でも)重なったオブジェクトを追加で選択状態とする。</p>
<p>枠線描画時に領域から外にマウスカーソルがはみ出した場合は、はみ出した方向とはみ出し量が通知される。
<br style="clear: both"/></p>


<h4>前提</h4>
<p>描画域はJComponent。</p>
<p>オブジェクト1つ1つにはSwingのコンポーネントは割り当てない(リソースの制約)。</p>
<p>想定オブジェクト最大数=10万。</p>

<h4>設計</h4>
<p>想定する利用者：</p>

<ol>
<li>Hacker:このフレームワーク自体の改造も行う。</li>
<li>Expert:このフレームワークを利用してGUIパーツを作成。(基本的にpublic/protectedメンバのみ使用)</li>
<li>User:Expertが作ったパーツを利用。フレームワークの存在すら知らないかもしれない。(基本的にpublicメンバのみ使用)</li>
</ol>

<p>下の方がよりスキルレベルは低くなる傾向があると思われる(実際どうかは別として)。なので下の利用者にとって、より分かり易くなければならない。フレームワークの都合で、Userが使用するクラスに不要なメンバが見えるのはよろしくない(「API仕様書に、このメソッドはフレームワークで使用するのでユーザは使用しないでください」みたいな)。フレームワーク内部処理用のメンバはpublicにしない。</p>

<h5>基本コンポーネント</h5>
<p><img src="fig005.png" style="float: left; margin: 2px 8px 2px 0px" alt="基本コンポーネント"/>
とりあえず、RectangleとかPointとかのイミュータブル版を作っておくことにする。</p>
<p>Rectはjava.awt.Rectangleのイミュータブル版。</p>
<p>RectBufferはミュータブル版。Stringに対するStringBuffer的存在。</p>
<p>RectAreaは共通インターフェース。Stringに対するCharSequence的存在。</p>
<p>Coordinateはjava.awt.Pointのイミュータブル版</p>
<p>Sizeはjava.awt.Dimensionのイミュータブル版

<br style="clear: both"/></p>
<h5>基本フレームワーク</h5>
<p><img src="fig006.png" alt="基本フレームワーク"/></p>
<h6>Model</h6>
<p>Modelは、このフレームワークで描画するオブジェクト。描画に関する知識は全く持たない。</p>

<h6>ModelView</h6>
<p>ModelViewは、オブジェクトの描画を行う。どうしてもprotectedインターフェースとpublicインターフェースを別々に提供したかったので、interfaceではなくabstract classになっている。</p>
<ul>
<li>protected void draw(RectArea area, Graphics g)<br/>
自分自身を描画する。引数のareaは描画対象領域。これを利用して自分が対象外なら描画しないように最適化することが可能。
</li>
<li>public Model getModel()<br/>
自分が描画を受け持っているModelを返送する。
</li>
<li>public RectArea getArea()<br/>
自分自身が内接する最小の矩形領域を返す。
</li>
<li>public boolean isHit(Coordinate co)<br/>
getArea()だと矩形領域なので、おおざっぱな情報しか得られない。isHit()は指定された座標が本当に自分自身とぶつかるかどうかを返す。
</li>
<li>public boolean isSelected()<br/>
このオブジェクトが選択済みであるかどうかを返す。
</li>
<li>protected void select(boolean b)<br/>
このオブジェクトを選択状態とする。
</li>
</ul>

<h6>ModelArena</h6>
<p>描画面を抽象化したもの。ModelViewを配置して表示する。描画面に対するModelの操作は、Swingに直接関係するもの以外は、このクラスを通して行なう。どうしてもprotectedインターフェースとpublicインターフェースを別々に提供したかったので、interfaceではなく空のabstract classになっている。</p>
<ul>
<li>public abstract void addModel(Model model)<br/>
ModelをModelArenaに追加する。これにより指定されたModelは自動的に描画される。
</li>
<li>protected abstract void draw(RectArea area, Graphics g)<br/>
描画面を描画するためのメソッド。JModelArenaComponent.paintComponent()からしか呼び出されない。間違って利用者から呼び出されないようにprotectedとなっている。
</li>
</ul>

<h6>JModelArenaComponent</h6>
<p>描画面のSwing実装。マウス関係のイベント処理の委譲、またawtからの描画要求をModelArenaに委譲する。基本的に丸投げするだけなのでSwing用アダプタといったところか。</p>

<h5>動的な挙動の検討</h5>
<h6>シナリオ：通常の描画処理</h6>
<p>描画が必要になると、awtのイベントディパッチスレッドは、paintComponent()を呼び出す。</p>
<pre>
    @Override protected void paintComponent(final Graphics g) {
        super.paintComponent(g);
        Rectangle clip = g.getClipBounds();
        g.setColor(getBackground());
        g.fillRect(clip.x, clip.y, clip.width, clip.height);
        g.setColor(getForeground());
        model.draw(Rect.getInstance(clip), g);
    }
</pre>
<p>JModelArenaComponent.paintComponent()は更新が必要な部分を背景色に塗りつぶした後、描画処理をModelArenaに委譲する。</p>
<p>ModelArenaとModelViewのデフォルト実装としてDefaultModelArenaとDefaultModelViewが提供される。</p>
<p><img src="fig007.png" style="float: left; margin: 2px 8px 2px 0px" alt="ModelArena"/>
JModelArenaComponentのpaintComponent()からDefaultModelArenaのdraw()が呼び出されると、</p>
<pre>
    @Override protected void draw(RectArea area, Graphics g) {
        for (ModelView mv:modelTable) {
            draw(mv, area, g);
        }
    }

    protected void draw(ModelView mv, RectArea area, Graphics g) {
        mv.draw(area, g);
    }
</pre>
<p>全てのModelViewに対してdraw()が呼び出される。DefaultModelViewのdraw()は、</p>
<pre>
    public void draw(RectArea area, Graphics g) {
        if (getArea().intersects(area)) {
            draw(g);
        }
    }
</pre>
<p>指定された描画領域に自分が入っているかをチェックして、入っていれば自分自身の描画を実行する。これによって描画面に各コンポーネントが描画される。</p>

<h6>シナリオ：Swingイベント処理</h6>
<p>イベント処理はModelArenaで行われるので、ModelArenaでMouseListenerやMouseMotionListenerを実装してしまえば簡単だが、そうするとModelArenaのpublicインターフェースにmouseXXX()メソッドが露出されることになるのでUserにはノイズになる。そこでJModelArenaComponent側でアダプタを用意してModelArena側に委譲する。</p>
<pre>
    public JModelArenaComponent() {
        addMouseListener(new MouseListener() {
            public void mouseClicked(MouseEvent e) {
                getModel().mouseClicked(e);
            }

            public void mousePressed(MouseEvent e) {
                getModel().mousePressed(e);
            }
            public void mouseReleased(MouseEvent e) {
                getModel().mouseReleased(e);
            }

            public void mouseEntered(MouseEvent e) {
                getModel().mouseEntered(e);
            }
            public void mouseExited(MouseEvent e) {
                getModel().mouseExited(e);
            }
        });

        addMouseMotionListener(new MouseMotionListener() {
            public void mouseDragged(MouseEvent e) {
                getModel().mouseDragged(e);
            }

            public void mouseMoved(MouseEvent e) {
                getModel().mouseMoved(e);
            }
        });
    }
</pre>
<p>これでmouseXXX()メソッドはprotectedにできるのでUserからは見えなくなる。</p>
<pre>
public abstract class ModelArena {
    protected abstract void mouseClicked(MouseEvent e);
    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void mouseEntered(MouseEvent e);
    protected abstract void mouseExited(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseMoved(MouseEvent e);
}
</pre>
<p><br style="clear: both"/></p>

<h6>シナリオ：左クリック</h6>

<p>mouseClicked()がawtイベントディスパッチスレッドから呼び出される。マウスイベントはJModelArenaComponentでModelArenaに委譲されるので、ModelArena.mouseClicked()が呼び出される。デフォルトの実装はDefaultModelArenaなので、DefaultModelArena.mouseClicked()が呼び出される。</p>

<h2>その他</h2>

<h3 id="objectSize">オブジェクト1個で何バイト？</h3>

<p>byteで持てばintで持つよりサイズを節約できるのか？ こんな感じのテストプログラムを作って、中にフィールド定義を追加しながら検証。環境：WindowsXP。コンパイルは、1.5.0_04で-target 1.3 -source 1.3。実行時は、-Xms256M -Xmx256Mを指定。</p>
<pre class="codeSample">
public class Test {
    public static void main(String[] args) throws Exception {
        Test[] array = new Test[1000000];
        System.gc();
        long start = Runtime.getRuntime().freeMemory();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = new Test();
        }
        System.gc();
        long used = start - Runtime.getRuntime().freeMemory();
        System.err.println(new java.text.DecimalFormat("0,000").format(used) + " used.");
    }
}
</pre>
<p>結果</p>
<table border="1" style="text-align:right">
  <tr style="text-align:center"><th>フィールド</th><th>1.3.1_17</th><th>1.4.2_09</th><th>1.5.0_04</th><th>IBM1.4.2SR3</th></tr>
  <tr><td style="text-align:center">無し</td><td>7,999,712</td><td>7,668,336</td><td>7,668,336</td><td>15,953,136</td></tr>
  <tr><td style="text-align:left">byte b;</td><td>15,999,712</td><td>15,999,712</td><td>15,668,336</td><td>15,953,136</td></tr>
  <tr><td style="text-align:left">byte b, b2;</td><td>15,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,936</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3;</td><td>23,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,968</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3;</td><td>23,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,968</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4;</td><td>23,999,712</td><td>15,999,712</td><td>15,668,336</td><td>31,957,104</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4, b5;</td><td>31,999,712</td><td>15,999,712</td><td>15,668,336</td><td>31,959,152</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4, b5, b6;</td><td>31,999,712</td><td>15,999,712</td><td>15,668,336</td><td>39,968,936</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4, b5, b6, b7, b8;</td><td>39,999,712</td><td>15,999,712</td><td>15,668,336</td><td>47,972,928</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4, b5, b6, b7, b8, b9;</td><td>47,999,712</td><td>23,999,712</td><td>23,668,336</td><td>47,972,896</td></tr>
  <tr><td style="text-align:left">int i;</td><td>15,999,712</td><td>15,999,712</td><td>15,668,336</td><td>15,953,136</td></tr>
  <tr><td style="text-align:left">int i, i2;</td><td>15,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,936</td></tr>
  <tr><td style="text-align:left">int i, i2, i3;</td><td>23,999,712</td><td>23,999,712</td><td>23,668,336</td><td>23,960,968</td></tr>
  <tr><td style="text-align:left">int i, i2, i3, i4;</td><td>23,999,712</td><td>23,999,712</td><td>23,668,336</td><td>31,957,104</td></tr>
  <tr><td style="text-align:left">byte b;<br/>int i;</td><td>15,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,952</td></tr>
  <tr><td style="text-align:left">byte b;<br/>byte b2;<br/>int i;</td><td>23,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,968</td></tr>
  <tr><td style="text-align:left">byte b;<br/>int i;<br/>byte b2;</td><td>23,999,712</td><td>15,999,712</td><td>15,668,336</td><td>23,960,968</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3, b4;<br/>int i1;</td><td>31,999,712</td><td>15,999,712</td><td>15,668,336</td><td>31,957,120</td></tr>
  <tr><td style="text-align:left">byte b, b2, b3;<br/>int i1;<br/>byte b4;</td><td>31,999,712</td><td>15,999,712</td><td>15,668,336</td><td>31,957,120</td></tr>
  <tr><td style="text-align:left">int i1;<br/>byte b, b2, b3, b4;</td><td>31,999,712</td><td>15,999,712</td><td>15,668,336</td><td>31,957,120</td></tr>
</table>
<ul>
<li>微妙にサイズが小さいのは謎。16バイトというのはIBM版の話だったのかも。SUN版だと8バイトのようだ。</li>
<li>1.3系とIBM版は、byteにしてもサイズの節約にはならない。</li>
<li>どの実行系も8バイト単位でメモリをアロケーションしている(今のIA32って8バイト境界に置くのが速いの？)。</li>
<li>フィールドの定義順には関係しない。</li>
</ul>
<hr/>
<p>
  <a href="http://validator.w3.org/check?uri=referer">
    <img src="http://www.w3.org/Icons/valid-xhtml10"
         alt="Valid XHTML 1.0 Strict" height="31" width="88" />
  </a>
</p>
<p>　<a href="mailto:ruimo@ruimo.com">ご感想をお聞かせください(ruimo@ruimo.com)。なお、誠に勝手ながら、HTMLメールはサーバーで全て削除されますので、テキストメールでお願いいたします。</a>
</p>
<p>　<a href="../..">戻る</a></p>
</body>
</html>
