<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"/>
  <link rel="stylesheet" type="text/css" href="/stylesheet.css"/>
  <title>Javaデスクトップアプリケーション</title>
</head>
<body>
<p>Sorry, English version is not available at this time.</a></p>
<h1>Javaデスクトップアプリケーション</h1>
<h4>最終更新日：2008/6/7</h4>

<hr/>
<h5>変更履歴<h5>
<p>
<table>
<tr>
  <td>2008/6/7</td>
  <td>JJUG資料への言及を追加。</td>
</tr>
</table>
</p>
<hr/>

<p>jsr295, jsr296で、Swingを用いたデスクトップアプリケーションの開発生産性の強化が予定されています。そこで、ここでは、その中の幾つかの機能を試してみたいと思います。</p>
<p>なお、<a href="http://www.ruimo.com/publication/index.html">「書きもの」トップページ</a>の方に、JJUGでこれらについて発表した内容があります。こちらには、操作を動画として録画したものと、NetBeans用のプロジェクトも置いてあるので、参考にしてください。</p>

<h2>準備</h2>

<p>Java SE 6を導入しておきます。<a href="http://java.sun.com/javase/downloads/?intcmp=1281">http://java.sun.comのダウンロードページ</a>から入手できます。</p>
<p>Swingアプリケーションの開発と言えば、もちろん<a href="http://www.netbeans.org">NetBeans</a>です。今回は6.1betaを使用しました。NetBeans自体のインストールは簡単なので、ここでは詳細は省略します。</p>
<p>NetBeans自体にはjsr295, jsr296の参照実装が含まれており、JavaDocも添付されています。しかしまだまだドキュメントは整備されていないので、ソースを読まないと、細かなところは分かりません。ソースも入手しておくことをお勧めします。</p>

<table border="1">
<tr>
<td>jsr295</td><td><a href="https://beansbinding.dev.java.net/">https://beansbinding.dev.java.net/</a></td>
</tr>
<tr>
<td>jsr296</td><td><a href="https://appframework.dev.java.net/">https://appframework.dev.java.net/</a></td>
</tr>
<tr>
<td>Swing Worker</td><td><a href="https://swingworker.dev.java.net/">https://swingworker.dev.java.net/</a></td>
</tr>
</table>

<p>ソースをダウンロードしたら、NetBeansに登録しておきましょう。Tools => Librariesを選んで、Library Managerを表示します。Swing Application Frameworkを選んでから、Sourceタブをクリック。Add JAR/Folder...ボタンを押して、jsr296とSwing Workerのソースを展開した場所を指定します。<br/>
<img src="libman1.png"/>
</p>
<p>同様にjsr295のソースを、Beans Bindingに登録します。<br/>
<img src="libman2.png"/>
</p>
<p>
これで、NetBeansの中からデバッガで追うことが可能になります。
</p>

<h2>サンプル1(テキストフィールドによる値編集)</h2>

<p>最初に最も簡単な例として、テキストフィールドで値を編集する例を見てみましょう。</p>

<p>NetBeansを立ち上げ、File -> New Projectを選びます。<br/>
<img src="newproject01.png"/>
</p>
<p>
Nextボタンを押し、プロジェクトの名前を指定します。ここではPersonにしています。<br/>
<img src="newproject02.png"/>
</p>
<p>
あとは、デフォルトのままでFinishボタンを押します。すると自動的にアプリケーションの雛形が作成されます。
</p>
<p>
ProjectsビューのPersonを右クリックして、Propertiesを選んでプロジェクトのプロパティを開き、まずApplicationの項目を修正します。<br/>
<img src="projectproperty01.png"/><br/>
ここは、ご自分の好きなように入力してみてください。Splash Screenを指定すると、アプリケーションが起動するまでの間に指定されたグラフィックを表示させることができます。
</p>
次にDesktop Appの項目を編集します。<br/>
<img src="projectproperty02.png"/><br/>
ここも、好きなように入力して構いません。ただしLinuxで実行する場合、Look & FeelはSun Defaultのままだと、NullPointerExceptionが発生して立ち上がらなくなってしまうので、Java Defaultに変更しておきます。編集し終ったらOKボタンを押します。
<p>
<p>
試しにF6を押して、実行してみましょう。<br/>
<img src="person01.png"/><br/>
</p>
<p>
FileメニューにはExitが、HelpメニューにはAboutが登録されています。試しにAboutをクリックすると、先ほど登録しておいた内容が表示されますね。しかし左側のグラフィックは何なのでしょう？ ちょっとこれを変更してみましょうか。<br/>
<img src="personabout01.png"/><br/>
</p>
<p>
今回は、これに差し替えてみることにします。<br/>
<img src="about.jpg"/><br/>
プロジェクトを作成したディレクトリの下の、src/person/resources/の下に、このファイル(about.jpg)を格納します。NetBeansのPrjectsビューの中で、Source Packages/person.resourceを展開すると、PersonAboutBox.propertiesがあるので、これをダブルクリックします。imageLabel.iconの行に、about.pngが指定されているので、そこをコメントアウトし(行の先頭に#を入れればコメントになります)、かわりにabout.jpgを指定します。<br/>
<img src="abouticon01.png"/><br/>
</p>
<p>
F11を押してコンパイルしたら、F6で実行し、Aboutを表示させてみましょう。<br/>
<img src="personabout02.png"/><br/>
うまくいきましたね。<br/>
</p>
<p>
これだけだと、なんなので仕組みを簡単に解説しておきましょう。Projectsビューから、PersonAboutBox.javaをダブルクリックします(ソースコードが表示された場合は、エディタ上部のDesignボタンを押して、デザインモードに切り替えます)。グラフィックの部分をクリックしてPropertiesビューのiconを見ると、about.jpgが設定されていますね。<br/>
<img src="abouticon02.png"/><br/>
</p>
<p>
すぐ横にある...というボタンを押してみましょう。<br/>
<img src="abouticon03.png"/><br/>
Image Within Projectは、クラスパスの中からイメージを読み込むことを指定しています。Define as a Resourceにチェックしておくと、フレームワークが、リソースファイルから、設定を読み出してくれます。リソースファイルというのは、先ほど編集したプロパティファイルのことです。そしてKey、Valueのところに、先ほど変更した行の内容が表示されているのが分かります。<br/>
<pre class="codeSample">
imageLabel.icon=about.jpg
</pre>
このようにNetBeansがリソースを管理してくれるため、リソースファイルのみを変更することで、表示内容を変更することができたわけです。
</p>
<p>
それでは、リソースファイルを使って、表示を日本語化してみましょう。もう一度PersonAboutBox.propertiesをダブルクリックします。この内容を日本語にすれば良いわけですが、今回はJavaのリソースバンドルの仕組みを使って、デフォルト(英語)と日本語の2つを用意してみます。こうしておくことで、アプリケーションの国際化が可能になります。Projectsビューから、PersonAboutBox.propertiesを右クリックし、Add Localeを選びます。<br/>
<img src="locale01.png"/><br/>
下のリストから、日本語を選びます。
</p>
<p>
日本語のロカールが追加されました。<br/>
<img src="locale02.png"/><br/>
ja_JPの方をダブルクリックして開きます。
</p>
<p>
早速日本語に修正します。<br/>
<img src="i18n01.png"/><br/>
</p>
<p>
修正したら、実行してみましょう。<br/>
<img src="person02.png"/><br/>
うまく反映されました。
</p>
<p>
同様にPersonApp.propertiesやPersonView.propertiesに日本語ロカールを追加して修正すれば、アプリケーション全体を日本語化できます(今回は、省略します)。
</p>
<p>
次にPersonクラスを作りましょう。src/person/の下にPerson.javaというファイルを作成します。私は単純なJavaのクラスはエディタで作る方が好きなので、エディタから打ち込みましたが、NetBeansでFile => New Fileメニューから作成しても、もちろんokです。
</p>
<pre class="codeSample">
package person;

public class Person {
    String name;
    int age;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}
</pre>

<p>
単なるJavaBeansですね。
</p>

<p>
ファイルが出来たらF11でコンパイルしましょう。コンパイルしたら、Projectsビューから、Person.javaを右クリックし、Tools => Add to Palette...を選びます。これでパレット(右上のボタンなどのGUIパーツが並んでいるところです)に、自分で作成したJavaBeansを登録することができます。今回は、Beansの下に登録しましょう。<br/>
<img src="palette01.png"/><br/>
</p>
<p>
これで、パレットのBeansの下にPersonが登録されたはずです。<br/>
<img src="palette02.png"/><br/>
</p>
<p>
これをアプリケーションに登録しましょう。Projectsビューの中のPersonView.javaをダブルクリックします。下のフォームビューからForm PersonViewを右クリックし、Add From Palette => Beans => Personを選択します。これで、Personがアプリケーションに追加されました。<br/>
<img src="palette03.png"/><br/>
</p>
<p>
それでは、まずアプリケーションのメインウィンドウに表示してみることにしましょう。まずLabelをPaletteでクリックしてから、アプリケーションの上に置きます。この時、以下のように補助線が表示される場所でクリックします。<br/>
<img src="label01.png"/><br/>
</p>
<p>
もう1つラベルを、右横に置きます。以下のような補助線が出る場所にします。<br/>
<img src="label02.png"/><br/>
</p>
<p>
ラベルの右端をマウスでドラッグして、ウィンドウの右端まで拡げます。やはり補助線が表示されるので、それに合わせます。<br/>
<img src="label03.png"/><br/>
これが名前の表示領域です。
</p>
<p>
次に年齢の表示領域を作成します。同様にラベルを2つ配置します。<br/>
<img src="label04.png"/><br/>
</p>
<p>
まず左側のラベルを設定しましょう。jLabel1をクリックし、Propertiesビューの中からtextを探します。<br/>
<img src="label05.png"/><br/>
右端の...ボタンを押します。ValueのところにNameと入力してEnterキーを押してから、OKを押します。<br/>
<img src="label06.png"/><br/>
</p>
<p>
同様にjLabel3にAgeを設定します。<br/>
</p>
<p>
次にProjectビューのperson.resourceの中から、PersonView.propertiesをダブルクリックしてみてください。<br/>
<img src="label07.png"/><br/>
今入力した内容が、自動的にリソースファイルに保存されていることが分かりますね。
</p>
<p>
jLabel1という名前は分かりにくいので、修正しましょう。Projectsビューから、PersonView.javaをダブルクリックします。インスペクタビューで、jLabel1を右クリックし、Change Variable Nameを選べば、名前を変更できます。今回は以下のように変更しました。<br/>
<img src="label08.png"/>
</p>
<p>
もう一度PersonView.propertiesを開いてみましょう。<br/>
<img src="label09.png"/><br/>
ちゃんとNetBeansが、名前の変更をリソースファイルの中にまで適用してくれているのが分かりますね。リソースファイルを日本語化する方法は既に解説しました。PersonView.propertiesを右クリックして、Add Locale...を選び、日本語を追加し、日本語のラベルを設定してください。<br/>
<img src="label10.png"/>
</p>
<p>
一度保存して、F6で実行してみましょう。<br/>
<img src="label11.png"/><br/>
ちゃんと表示されていますね。
</p>
<p>
次にPersonオブジェクトの内容を、右側に表示します。これはバインドという機能を使用します。既に、上でPersonオブジェクトをPersonViewに追加済みですから、これをラベルにバインドしてやります。PersonView.javaをダブルクリックして開いたら、フォームビューからnameValueLabelを右クリックし、Bind => textを選びます。Binding Sourceにはperson1を、Binding Expressionにはnameをドロップダウンリストから選択してやります。<br/>
<img src="binding01.png"/><br/>
</p>
<p>
同じように、ageValueLabelには、Bindin Sourceにperson1を、Binding Expersisonにageをバインドしてやります。設定はこれだけです。保存して実行してみましょう。<br/>
<img src="binding02.png"/><br/>
Personオブジェクトの初期値が表示されているのが分かりますね。これだけではつまらないので、Personの編集画面を作りましょう。
</p>

<p>
Projectsビューで、personパッケージを右クリックし、New => Other...を選びます。Swing GUI Formsの名からJDialogを選びNextをクリックします。<br/>
<img src="newdialog01.png"/><br/>
</p>
<p>
名前はEditPersonDialogにしました。<br/>
<img src="newdialog02.png"/><br/>
Finishボタンを押すと、ダイアログが作成されます。
</p>
<p>
上で作成したメインウィンドウには、ラベルを4つ配置しましたが、今度は編集なので、右側はテキストフィールドにします。前と同様にして部品を並べてください。<br/>
<img src="editdialog01.png"/><br/>
</p>
<p>
名前を付けてやります。やり方は前と同じです。右クリックしてChange Variable Nameでしたね。<br/>
<img src="editdialog02.png"/><br/>
</p>
<p>
ボタンを2つ追加します。これも補助線を頼りに、ウィンドウの右下に配置してください。名前は、cancelButtonとokButtonにしました。<br/>
<img src="editdialog03.png"/><br/>
</p>
<p>
前と同様にラベルを設定しましょう。プロパティビューのtextを選び、...ボタンで設定です。ボタンもラベルと同じようにして設定できます。<br/>
<img src="editdialog04.png"/><br/>
</p>
<p>
ニモニックを設定します。これはAlt+英字キーのショートカットの設定です。今回はOKボタンにOを、CancelボタンにCを割り当てました。<br/>
<img src="editdialog05.png"/><br/>
設定すると、下線が描画されます。<br/>
<img src="mnemonic01.png"/><br/>
</p>
<p>
Nameラベルをクリックし、labelForプロパティを設定します。これは、このラベルが、どのコンポーネントのラベルとして使用されているかを設定します。もちろん、今回はnameValueTextFieldを指定します。<br/>
<img src="labelfor01.png"/><br/>
同様にAgeラベルには、ageValueTextFieldを設定します。
</p>
<p>
NameラベルのdisplayedMnemonicを設定します。今回はNameにはNを、AgeにはAを割り当てました。<br/>
<img src="mnemonic02.png"/><br/>
同様にラベルにも下線がひかれます。
</p>
<p>
テストしてみましょう。エディタの上部にある目がついたアイコンでテストできます。Alt+N、Alt+A、Alt+O、Alt+Cを押してみて、上で設定したニモニックがちゃんと機能しているか確認しましょう。okならXアイコンで終了します。<br/>
<img src="test01.png"/><br/>
</p>
<p>
今回は、このダイアログに、Personオブジェクトを渡したいので、メインウィンドウの時と同様にPersonオブジェクトを追加します。フォームビューでOther Componentsを右クリックし、Add From Palette => Beans => Personを選びます。<br/>
<img src="error03.png"/><br/>
</p>
<p>
名前をperson1からpersonに変更しておきます。これはラベルやボタンの名前変更と同じです。インスペクタビューで、右クリックしてChange Variable Nameです。メインウィンドウ側もpersonに変えておいてください。さてメインウィンドウのPersonViewから、EditPersonDialogに編集対象のPersonオブジェクトを渡すため、コンストラクタを少々変更することにします。
</p>
<pre class="codeSample">
    public EditPersonDialog(java.awt.Frame parent, Person person) {
        super(parent, true);
        if (person == null) throw new NullPointerException("person is null");
        this.person = person;
        initComponents();
    }
</pre>
<p>
安全のため、引数のpersonはnullを許さないようにしてあります。
</p>
<p>
この変更によって、EditPersonDialogの中のmain()メソッドがエラーになります。このメソッドはテスト用にNetBeansが生成したものなので、今回は削除してしまいましょう。
</p>
<p>
さて、実は、これだけでは不十分です。というのもNetBeansが生成したコードは、initComponents()メソッドの中に以下のような行を含んでおり、せっかくコンストラクタで渡しても、上書きされてしまうのです。
</p>
<pre class="codeSample">
        person = new person.Person();
</pre>
<p>
更にもう1つ設計上の問題があります。EditPersonDialogは、ユーザが入力域に入力すると、その都度Personオブジェクトを変更してしまいます。このため、PersonViewからもらったPersonオブジェクトを直接EditPersonDialog側に設定してしまうと、キャンセルボタンを押しても、その時点では既にPersonオブジェクトが変更された後になってしまい、意味を成さなくなってしまうのです。このためもらったPersonオブジェクトのコピーを作り、OKボタンが押されたら、そこで初めて値をPersonView側に設定するようにしなければなりません。そこでPersonクラスをClonableにすることにします。
</p>
<pre>
public class Person implements Cloneable {
    String name;
    int age;

    public Person clone() {
        try {
            return (Person)super.clone();
        }
        catch (CloneNotSupportedException ex) {
            throw new RuntimeException(ex);
        }
    }
...
</pre>
<p>
そして、EditPersonDialogの、personのインスタンス生成コードを変更します。EditPersonDialog.javaをダブルクリックして、インスペクタビューの中のOther Componentsを展開し、personをクリックします。プロパティビューのCodeというボタンを押すと、Custom Create Codeという項目があります。ここにperson.clone();と入力します。</p>

<img src="clone01.png"/><br/>
</p>

<p>
これでinitComponents()の中のコードは、以下のように変わります。<br/>
</p>
<pre class="codeSample">
        person = person.clone();
</pre>

<p>
では、バインドしましょう。エディタ上部のDesignボタンを押して、デザインモードに切り替えます。インスペクタビューからnameValueTextFieldを右クリックし、Bind => textを選びます。メインウィンドウの時と同様にして、personのnameプロパティを割り当てましょう。<br/>
<img src="binding03.png"/><br/>
同様にして、ageValueTextFieldにはageプロパティを割り当ててください。
</p>
<p>
それでは、メインウィンドウから、このダイアログを表示することにしましょう。すでにメインウィンドウには、Aboutダイアログを表示するロジックがあるので、これを真似すれば良いのです。まず編集のためのボタンを作りましょう。PersonView.javaをダブルクリックしてボタンを配置します。<br/>
<img src="editbutton01.png"/><br/>
名前をeditButtonに変更しておきます(もう慣れたでしょうから、やり方は省略します)。
</p>
<p>
次にボタンの動作を登録します。プロパティビューからactionを選び、...をクリックし、Actionのドロップダウンから、Create New Actionを選びます。<br/>
<img src="createaction01.png"/><br/>
</p>
<p>
以下の図のように設定します。<br/>
<img src="createaction02.png"/><br/>
これで、PersonViewクラスにeditPerson()というメソッドが用意され、ボタンを押すと、このメソッドが呼ばれるように設定されます。ソースを見ると、以下のようなメソッドが用意されているのが分かります。
</p>
<pre class="codeSample">
    @Action
    public void editPerson() {
    }
</pre>
<p>
Tool Tipに設定した文字列は、ボタンの上にマウスを乗せた状態にすると表示される、簡単なヘルプです。Acceleratorを設定しているので、Ctrl-Eを押すことでも、このボタンを押すことができます。
</p>
<p>
上で作ったPerson編集ダイアログを表示するコードを書きましょう。すぐ上にAboutダイアログを表示するメソッドがあるので、それを真似すれば良いのです。さて、上で述べた通り、EditPersonDialogは、受け取ったPersonオブジェクトのコピーを作って、その内容を更新します。従ってもしもCancelボタンが押されたら、単にその内容を捨て、OKボタンが押されたら変更されたPersonオブジェクトを取り込めば良いことになります。EditPersonDialogが持っているPersonオブジェクトにアクセスできるよう、まずはゲッタを作りましょう。EditPersonDialogのソースを表示し、ソース上で右クリック => Refactor => Encupslate Fields...を選びます。personフィールドのCreate Getterの所にチェックを入れて、Refactorボタンを押せばゲッタが生成されます。<br/>
<img src="getter01.png"/><br/>
</p>
<p>
EditPersonDialogのOKボタンとCancelボタンの処理を作成します。OKボタンをクリックし、上でEditボタンの処理を作成した時と同様に、actionプロパティの...ボタンを押してアクションを作ります。<br/>
<img src="okbutton01.png"/><br/>
今回は、OKボタンにokButtonPerformed()メソッドを、CancelボタンにcancelButtonPerformed()を割り当てました。とりあえずはメソッドの中身は空っぽにしておきます。
</p>
<p>
それではEditPersonDialogを表示する処理を見てみましょう。PersonView.javaのeditPerson()メソッドの中身を実装します。
</p>
<pre class="codeSample">
    @Action
    public void editPerson() {
        EditPersonDialog editPersonDialog = new EditPersonDialog(getFrame(), person) { // (1)
            @Override public void okButtonPerformed() {
                Person oldPerson = PersonView.this.person;
                person = getPerson();
                for (Binding b : bindingGroup.getBindings()) { // (3)
                    if (b.getSourceObject() == oldPerson) { // (4)
                        b.unbind(); // (4)
                        b.setSourceObject(person); // (4)
                        b.bind(); // (4)
                    }
                }
                dispose();
            }
            
            @Override public void cancelButtonPerformed() {
                dispose(); // (2)
            }
        };
        editPersonDialog.setLocationRelativeTo(getFrame()); // (5)
        ((SingleFrameApplication)getApplication()).show(editPersonDialog); // (5)
    }
</pre>
<p>
まず、EditPersonDialog()にPersonオブジェクトを渡してインスタンスを作りますが、この時、継承をしてokButtonPerformed()とcancelButtonPerformed()をオーバーライドします(1) 。cancelButtonPerformed()の場合は、単にダイアログを削除して終わりです(2)。OKボタンの処理ですが、jsr295, 6では、バインディングという仕組みでJavaBeansとコンポーネントを結び付けています。現在のバインディングは、bindingGroupのgetBindings()を呼び出せば一覧できます(3)。各バインディングが、Personオブジェクトに紐付いているかを調べ、もしそうならば一旦バインドを解除してから、新しいPersonオブジェクトにバインドしてやります。あとは、Aboutダイアログの時と同様のコードでダイアログを表示してやります。Person編集内容の反映には、今回の方法の他に、プロパティをそれぞれコピーしてやる方法が考えられます。この方法をとるには、Personクラスを正式なJavaBeansにする必要があるため、次章で解説します。それでは実行して、値を変更してみてください。<br/>
<img src="person03.png"/><br/>
</p>
<p>
次に値のチェックを行えるようにしてみましょう。まずEditPersonDialogの右側にエラーを表示するため、場所を開けます。<br/>
<img src="editdialog06.png"/><br/>
</p>
<p>
エラー表示用のラベルを配置します。<br/>
<img src="error01.png"/><br/>
</p>
<p>
エラー表示用のラベルのtextプロパティを削除しておきます。<br/>
<img src="error02.png"/>
<p>
コンポーネントの名前を変更します。今回はnameErrorLabel、ageErrorLabelとしておきました。<br/>
<img src="error03.png"/><br/>
</p>
<p>
バインディングを区別したいので、バインディングに名前を付けておきます。EditPersonDialogのnameValueTextFieldのtextプロパティへのバインディングを開きます。Advancedのタブを開き、Identificationのところにperson.nameと入力します。<br/>
<img src="binding04.png"/><br/>
同様にageValueTextFieldのtextプロパティへのバインディングにperson.ageという名前を付けます。
</p>
<p>
バインディングの際のエラーを受け取るには、BindingListenerを登録します。EditPersonDialogのコンストラクタでリスナを登録して、バインディングのエラーを受け取れるようにしましょう。
</p>
<pre class="codeSample">
    public EditPersonDialog(java.awt.Frame parent, Person person) {
        super(parent, true);
        if (person == null) throw new NullPointerException("person is null");
        this.person = person;
        initComponents();
        bindingGroup.addBindingListener(new BindingListener() {
            public void bindingBecameBound(Binding binding) {}
            public void bindingBecameUnbound(Binding binding) {}

            public void syncFailed(Binding binding, SyncFailure failure) { // (1)
                ResourceMap resourceMap =
                    Application.getInstance(PersonApp.class)
                    .getContext().getResourceMap(EditPersonDialog.class);
                if ("person.name".equals(binding.getName())) { // (2)
                    if (failure.getType() == SyncFailureType.VALIDATION_FAILED) { // (3)
                        nameErrorLabel.setText(resourceMap.getString("invalid.value.error")); // (5)
                    }
                }
                else if("person.age".equals(binding.getName())) { // (2)
                    if (failure.getType() == SyncFailureType.CONVERSION_FAILED) { // (3)
                        ageErrorLabel.setText(resourceMap.getString("number.format.error")); // (4)
                    }
                    else if (failure.getType() == SyncFailureType.VALIDATION_FAILED) { // (3)
                        ageErrorLabel.setText(resourceMap.getString("invalid.value.error")); // (5)
                    }
                }
            }

            public void synced(Binding binding) {
                nameErrorLabel.setText("");
                ageErrorLabel.setText("");
            }

            public void sourceChanged(Binding binding, PropertyStateEvent event) {}
            public void targetChanged(Binding binding, PropertyStateEvent event) {}
        });
    }
</pre>
<p>
syncFailed()は、コンポーネントの値をJavaBeansに反映できなかった場合に呼び出されます(1)。バインディングに名前を付けておいたので、(2)のようにして、どのバインディングでエラーが発生したのかを識別することができます(名前を付けておかないと、binding.getName()はnullを返します)。SyncFailureオブジェクトのgetType()を呼び出すことで、エラーの種類を特定できます。コンポーネントに設定された値を、バインド先に反映する場合、型変換、バリデーションの順に処理が行われます。例えば、今回の年齢フィールドの場合、テキストフィールドなので、数字以外の文字列も入力できてしまいます。そうした場合にはCONVERSION_FAILEDというエラーになります。型変換に成功したとしても例えば年齢が500歳とかだったら、おかしいですね。このようなエラーはVALIDATION_FAILEDで通知されます。そこで、今回はCONVERSION_FAILEDなら、"number.format.error"というリソースを(4)、VALIDATION_FAILEDならば"invalid.value.error"というリソースの内容を(5)表示するようにしています。もちろん、このエラーメッセージは、EditPersonDialog.propertiesに設定します。そろそろ日本語のリソースも作成しておきましょう。方法は覚えていますか？ EditPersonDialog.propertiesを右クリックし、Add Locale...を選んで、リストから日本語を選択します。日本語のリソースファイルを作成しましょう。
</p>

<pre class="codeSample">
nameLabel.text=名前
ageLabel.text=年齢
okButton.text=OK
cancelButton.text=キャンセル（C)
okButtonPerformed.Action.text=OK
okButtonPerformed.Action.shortDescription=
cancelButtonPerformed.Action.shortDescription=
cancelButtonPerformed.Action.text=キャンセル(C)
nameErrorLabel.text=
ageErrorLabel.text=
number.format.error=数値を入力してください。
invalid.value.error=値が不適当です。
</pre>

<p>
以下は編集画面で、年齢のところに"aaa"と入力した例です。<br/>
<img src="conversionerror01.png"/><br/>
</p>

<p>
せっかくなので赤で表示するようにしておきましょう。これまでのプロパティ設定と同様にforegroundプロパティを設定してやるだけです。<br/>
<img src="setcolor01.png"/><br/>
<img src="conversionerror02.png"/><br/>
</p>

<p>
さて、上でVALIDATION_FAILEDというエラーについて定義しましたが、まだバリデータを登録していないので、このエラーメッセージは出力されません。今度はバリデータを登録しましょう。次ようなチェックをすることにします。<br/>
<table border="1">
<tr>
<th>フィールド</th><th>チェック内容</th>
</tr>
<tr>
<td>名前</td><td>長さが1以上</td>
</tr>
<tr>
<td>年齢</td><td>0以上300以下</td>
</tr>
</table>
</p>

<p>
バリデータは、クラスとして作成します。次のようなバリデータを用意することにしましょう。<br/>
<table border="1">
<tr>
<th>バリデータ クラス</th><th>チェック内容</th>
</tr>
<tr>
<td>RequiredValidator</td><td>nullでないこと。文字列型の場合は、更に長さが0で無いこと。</td>
</tr>
<tr>
<td>MinMaxValidator</td><td>値指定された範囲であること。</td>
</tr>
</table>
</p>

<p>
最初にRequredValidatorを見てみましょう。
</p>
<pre class="codeSample">
package person;

import org.jdesktop.beansbinding.Validator;

public class RequiredValidator extends Validator&lt;Object&gt; { // (1)
    enum ErrorCode {
        NULL_VALUE, LENGTH_ZERO;
    }

    public final Validator.Result NULL_VALUE // (3)
        = new Validator.Result(ErrorCode.NULL_VALUE, "Null is not permitted.");
    public final Validator.Result LENGTH_ZERO
        = new Validator.Result(ErrorCode.LENGTH_ZERO, "Length zero.");

    @Override
    public Validator.Result validate(Object value) { // (2)
        if (value == null) return NULL_VALUE;
        if (value instanceof CharSequence &&
            ((CharSequencevalue).length() == 0)) return LENGTH_ZERO;
        return null;
    }
}
</pre>
<p>
バリデータは、Validatorクラスを継承して作成します。Validatorは型パラメータを持つことができますが、今回はあらゆる型のプロパティに利用可能バリデータなので、Objectを指定しています(1)。バリデータクラスで実装が必要なのは、validate()メソッドです(2)。validate()メソッドは、バリデーションでエラーが無ければnullを、そうでなければValidator.Resultクラスのインスタンスを返すようにします。今回は、nullのケースと、文字列で長さ0のケースで別のResultを用意しました。Validate.Resultはイミュータブルなので、使い回して構いません。ただし残念ながら、なぜかstaticなネステッドクラスになっていないので、ここでは非スタティックなfinalフィールドで宣言してあります(3)。あとはプロパティを調べて適切なResultを返すようにvalidate()メソッドを実装するだけです。
</p>
<p>
バリデータもJavaBeansとして登録します。せっかくなので、パレットにValidatorというカテゴリを新設しておくことにしましょう。PaletteのMiscカテゴリの上で、右クリックし、Create New Categoryを選択します。<br/>
<img src="palette04.png"/><br/>
<br/>
Validatorと入力してValidatorカテゴリを作ります。<br/>
<img src="palette05.png"/><br/>
</p>
<p>
あとは、これまでと同様に、RequiredValidatorをValidatorカテゴリに登録し、EditPersonDialogに追加してください。<br/>
<img src="validator01.png"/><br/>
</p>

<p>
nameValueTextFieldに登録しましょう。プロパティからBindingを選んで、textプロパティの...ボタンを押します。Binding設定のAdvancedというタブを選ぶと、Validatorの設定があるので、ここにrequiredValidator1を設定してやります。さて、上で、VALIDATION_FAILEDの時には、invalid.value.errorというメッセージを表示するようにしましたね。
</p>
<pre class="codeSample">
    if ("person.name".equals(binding.getName())) { // (2)
        if (failure.getType() == SyncFailureType.VALIDATION_FAILED) { // (3)
            nameErrorLabel.setText(resourceMap.getString("invalid.value.error")); // (5)
        }
    }
</pre>
<p>
EditPersonDialogのリソースに日本語のロカールを追加して、メッセージを追加しましょう。
</p>
<pre class="codeSample">
nameLabel.text=名前
ageLabel.text=年齢
...
number.format.error=数値を入力してください。
invalid.value.error=値が不適当です。
</pre>
<p>
それではアプリケーションを起動して、Person編集画面を表示し、名前のフィールドに何か入力してから、全て削除してフィールドを空にしてみてください。<br/>
<img src="validator03.png"/><br/>
<br/>
エラーメッセージが表示されましたね。ただ、このメッセージは、バリデーション失敗の時の一般的なメッセージとして用意したので、今ひとつ的確ではないですね。BindingListenerのsyncFailed()メソッドが呼び出された時に渡されるSyncFailureオブジェクトは、バリデータが返したResultオブジェクトを保持しているので、これを判別すれば、もっと適切なメッセージを出力することができます。RequredValidatorは長さ0のエラーの時、エラーコードとして、ErroCode.LENGTH_ZEROを渡していました。
</p>
<pre class="codeSample">
    public final Validator.Result LENGTH_ZERO
        = new Validator.Result(ErrorCode.LENGTH_ZERO, "Length zero.");
</pre>
<p>
これを使って判定しましょう。
</p>
<pre class="codeSample">
    public void syncFailed(Binding binding, SyncFailure failure) {
        ResourceMap resourceMap =
            Application.getInstance(PersonApp.class)
            .getContext().getResourceMap(EditPersonDialog.class);
        if ("person.name".equals(binding.getName())) {
            if (failure.getType() == SyncFailureType.VALIDATION_FAILED) {
                if (failure.getValidationResult().getErrorCode() == // (1)
                    RequiredValidator.ErrorCode.LENGTH_ZERO)
                {
                    nameErrorLabel.setText(resourceMap.getString("length.zero.error")); // (2)
                }
                else {
                    nameErrorLabel.setText(resourceMap.getString("invalid.value.error"));
                }
            }
        }
</pre>
<p>
リザルトコードをチェックして、長さ0のエラーを判定し(1)、エラーメッセージを設定しています(2)。あとはEditPersonDialogのリソースにエラーメッセージを追加するだけです。
</p>
<pre class="codeSample">
length.zero.error=入力してください。
</pre>
<p>
実行してみましょう。<br/>
<img src="validator04.png"/><br/>
</p>
<p>
うまく表示されました。次にMinMaxValidatorを作成してみましょう。
</p>
<pre class="codeSample">
package person;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import org.jdesktop.beansbinding.Validator;

public class MinMaxValidator&lt;T extends Number&gt; extends Validator&lt;T&gt; {
    public enum ErrorCode {
        BELOW_MIN, ABOVE_MAX;
    }

    T min;
    T max;

    public void setMin(T min) {
        this.min = min;
    }

    public T getMin() {
        return min;
    }

    public void setMax(T max) {
        this.max = max;
    }

    public T getMax() {
        return max;
    }

    static final Map&lt;Class&lt;? extends Number&gt;, Comparator&lt;? extends Number&gt;&gt; comparatorTable
        = new HashMap&lt;Class&lt;? extends Number&gt;, Comparator&lt;? extends Number&gt;&gt;();
    static {
        comparatorTable.put(Byte.class, new Comparator&lt;Byte&gt;()
            {public int compare(Byte b1, Byte b2) {return b1.compareTo(b2);}});
        comparatorTable.put(Integer.class, new Comparator&lt;Integer&gt;()
            {public int compare(Integer i1, Integer i2) {return i1.compareTo(i2);}});
        comparatorTable.put(Double.class, new Comparator&lt;Double&gt;()
            {public int compare(Double d1, Double d2) {return d1.compareTo(d2);}});
        comparatorTable.put(Float.class, new Comparator&lt;Float&gt;()
            {public int compare(Float f1, Float f2) {return f1.compareTo(f2);}});
        comparatorTable.put(Long.class, new Comparator&lt;Long&gt;()
            {public int compare(Long l1, Long l2) {return l1.compareTo(l2);}});
        comparatorTable.put(Short.class, new Comparator&lt;Short&gt;()
            {public int compare(Short s1, Short s2) {return s1.compareTo(s2);}});
    }

    public final Validator.Result BELOW_MIN
        = new Validator.Result(ErrorCode.BELOW_MIN, "Value is less than minimum value.");
    public final Validator.Result ABOVE_MAX
        = new Validator.Result(ErrorCode.ABOVE_MAX, "Value exceeds maximum value.");

    @Override
    public Validator&lt;T&gt;.Result validate(T value) {
        if (value == null) return null;
        Comparator&lt;T&gt; cmp
            = (Comparator&lt;T&gt;)comparatorTable.get(value.getClass());
        if (cmp == null)
            throw new RuntimeException("Unsupported type:" + value.getClass());
        if (cmp.compare(value, min) &lt; 0) return BELOW_MIN;
        if (cmp.compare(max, value) &lt; 0) return ABOVE_MAX;
        return null;
    }
}
</pre>
<p>
ちょっと欲張って、byte, short, integer, long, float, doubleの全てに対応しています。このため少々複雑になっていますが、ロジック自体はそれほど難しくは無いはずです。最小値と最大値は外から設定できるようにし、それとバリデータに渡された値とを比較して、最小値より小さければBELOW_MINを、最大値よりも大きければABOVE_MAXを返すようにしてあるだけです。RequiredValidatorの時と同様にパレットに追加して、EditPersonDialogに追加してください。このバリデータは最大値と最小値を保持するので、今回は名前をageValidatorに変えておきましょう。<br/>
<img src="validator05.png"/><br/>
</p>
<p>
今回のJavaBeansは型パラメータ付きなので、プロパティシートのCodeのページでTypeParametersを指定しておきます。年齢はintなので&lt;Integer&gt;を設定します。<br/>
<img src="validator06.png"/><br/>
</p>
<p>
残念ながら、現バージョンのNetBeansでは、型パラメータをIntegerにしてやっても、max, minのプロパティはIntegerとは認識されないようで、プロパティシートに直接値を設定することはできません。<br/>
<img src="validator07.png"/><br/>
</p>
<p>
今回は、...ボタンを押し、メニューからCustom codeを選んで、値を指定することにします。<br/>
<img src="validator08.png"/><br/>
minには0を、maxには300を指定します。それでは実行してみましょう。<br/>
<img src="validator09.png"/><br/>
範囲外の値を入力するとエラーになっているのが分かりますね。もちろん、これも前と同じようにもっと分かり易いメッセージにすることができます。もうやり方は想像できますね？
</p>
<pre class="codeSample">
    else if("person.age".equals(binding.getName())) {
        if (failure.getType() == SyncFailureType.CONVERSION_FAILED) {
            ageErrorLabel.setText(resourceMap.getString("number.format.error"));
        }
        else if (failure.getType() == SyncFailureType.VALIDATION_FAILED) {
            if (failure.getValidationResult().getErrorCode() ==
                MinMaxValidator.ErrorCode.BELOW_MIN)
            {
                ageErrorLabel.setText
                    (String.format(resourceMap.getString("min.value.error"),
                                   ageValidator.getMin(),
                                   ageValidator.getMax()));
            }
            else if (failure.getValidationResult().getErrorCode() ==
                     MinMaxValidator.ErrorCode.ABOVE_MAX)
            {
                ageErrorLabel.setText
                    (String.format(resourceMap.getString("max.value.error"),
                                   ageValidator.getMin(),
                                   ageValidator.getMax()));
            }
            else {
                ageErrorLabel.setText(resourceMap.getString("invalid.value.error"));
            }
        }
    }
</pre>
<p>
特に解説は必要無いかと思います。RequiredValidatorと異なるのは、メッセージの中に最小、最大値を出力したいので、String.format()を使って、メッセージを組み立てている点でしょう。リソースは以下のように設定しました。
</p>
<pre class="codeSample">
min.value.error=値が小さ過ぎます。(%1$,d &lt; 値 &lt; %2$,d である必要があります)
max.value.error=値が大き過ぎます。(%1$,d &lt; 値 &lt; %2$,d である必要があります)
</pre>
<p>
実行して範囲外の値を入力すると、以下のように表示されます。<br/>
<img src="validator10.png"/><br/>
</p>
<hr/>
<p>
  <a href="http://validator.w3.org/check?uri=referer">
    <img src="http://www.w3.org/Icons/valid-xhtml10"
         alt="Valid XHTML 1.0 Strict" height="31" width="88" />
  </a>
</p>
<p>　<a href="mailto:ruimo@ruimo.com">ご感想をお聞かせください(ruimo@ruimo.com)。なお、誠に勝手ながら、HTMLメールはサーバーで全て削除されますので、テキストメールでお願いいたします。</a>
</p>
<p>　<a href="/">トップページへ</a></p>
</body>
</html>
