<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link rel="stylesheet" type="text/css" href="/stylesheet.css"/>
  <title>Ruby 3 動的回路シミュレータの解答例</title>
</head>
<body>
<h1>Ruby 3 動的回路シミュレータの解答例</h1>
<p>この内容は「Ruby 3 オブジェクト指向とはじめての設計」で取り上げた、動的回路シミュレータの最終形の1解答例です。ページの関係で、あふれてしまったので、ここに公開します。</p>

<div class="disclaimer">ここにある文書が正しかったこと、正しくなかったことによって生じたあらゆる結果に対して、当方は一切の保証を行いません。</div>
<p/>
<div class="lastUpdate">最終更新日 2009/8/23</div>
<hr/>

<h2>動的回路シミュレータを完成させる。</h2>

<p>入力の全パターンを与えて、素子の遅延時間を測定することが目的でしたが、本書の中で解説したプログラムでは、オブザーバパターンを用いているため、出力が変化しないとテスタが呼び出されず、遅延時間の測定ができない問題がありました。</p>

<p>これを解決するには2つの方法が考えられます。1つ目は、入力パターンが変わるごとに全てのデバイスを作り直すという方法、もう1つは、状態をリセットする手段を用意して、全端子の状態をnilに戻せるようにする方法です。</p>

<p>全てのデバイスを作り直すという方法は、若干オーバーヘッドがありますが、悪い方法ではありません。毎回オブジェクトが新規に生成されるので、確実に状態を初期状態に戻すことができます。今回はデバイスを引数に渡してやれば、そのデバイスに全ての入力パターンを与えるメソッドを、Simulatorに作成することを予定しています。全てのデバイスを作り直すのだとすると、回路の組み立て処理を何らかの形で、このメソッドに渡さなければなりません(おそらくはブロックで渡すことになるでしょう)。これは呼び出す側にとっては、面倒です。そこで今回は後者の方法をとることにします。</p>

<p>全Terminalの状態をnilにリセットする機能を作成することにします。まずSimulatorで、生成した全てのデバイスを管理できるようにします。そのために、</p>

<ol>
<li>SimulatorにLogicDeviceを保存するための配列を用意します。</li>
<li>registerDeviceメソッドを用意し、引数で渡されたLogicDeviceを、1.で作成した配列に追加します。</li>
<li>resetメソッドを用意します。これは、@current_timeを0とし、配列に保持している全LogicDeviceのインスタンスのresetを呼び出して、全デバイスのリセットを行います。</li>
</ol>

<pre class="codeSample">
  class Simulator
    def initialize
      @current_time = 0
      @command_list = SortedList.new
      @device_list = []
    end
...
    def reset
      @current_time = 0
      @device_list.each{|d| d.reset}
    end

    def register_device(device)
      @device_list %lt;%lt; device
    end
...
</pre>

<p>次に、LogicDeviceのinitializeメソッドで、引数として渡されたSimulatorのregisterDeviceメソッドを呼び出し、その時に、自分自身を渡すようにします。そしてLogicDeviceにresetメソッドを追加します。これは、自分自身の入力、出力端子の全てのresetメソッドを呼び出します。</p>

<pre class="codeSample">
  class LogicDevice
    def initialize(input_count, output_count, simulator)
      @input_count = input_count
      @output_count = output_count
      @input_terminals = Array.new(input_count) {|i| Terminal.new}
      @output_terminals = Array.new(output_count) {|i| Terminal.new}
      @simulator = simulator
      simulator.registerDevice(self)
    end
...
    def reset
      @input_terminals.each {|t| t.reset}
      @output_terminals.each {|t| t.reset}
    end
</pre>

<p>最後に、Terminalにresetというメソッドを追加すれば完了です。</p>

<h3>■ 小問題</h3>

<p>Terminalにresetメソッドを追加してください。これは、Terminalの状態をnilに設定します。ただ、この時にオブザーバが呼び出されないように注意してください。</p>

<h3>解答</h3>
<pre class="codeSample">
  class Terminal
...
    def reset
      @current_state = nil
    end
  end
</pre>

<p>Simulatorのresetメソッドを呼び出せば、全端末の状態をnilにリセットすることができるようになりました。それでは、Simulatorに、デバイスのテストを行うメソッドを追加することにしましょう。本書の前章の、練習問題2-(2)を参考にして、与えられた入力数の全入力パターンを生成するpermutationメソッドを作成し、CircuitSimulatorモジュールに追加します。</p>

<pre class="codeSample">
  def self.permutation(input_digits, input = [], &amp;proc)
  end
</pre>

<p>モジュールはインスタンス生成できませんから、特異メソッドにする必要があります。各入力パターンは、配列として生成され、生成された配列は、procに渡されます。例えば、</p>

<pre class="codeSample">
  CircuitSimulator.permutation(2) do |input_pattern|
    puts("#{input_pattern}")
  end
</pre>

<p>を実行すると、以下のように表示されるものとします。</p>

<pre class="codeSample">
[0, 0]
[0, 1]
[1, 0]
[1, 1]
</pre>

<pre class="codeSample">
module CircuitSimulator
...
  def self.permutation(input_digits, input = [], &amp;proc)
    if input_digits == input.length
      proc.call(input)
    else
      permutation(input_digits, input + [0], &amp;proc)
      permutation(input_digits, input + [1], &amp;proc)
    end
  end
end
</pre>

<p>このようにモジュールには、クラスだけではなく、メソッドを追加することもできます。これはモジュール名.メソッド名で呼び出すことが可能です。それでは、これを利用して、Simulatorに、test_circuitメソッドを追加しましょう。これは、与えられたデバイスの全入力パターンをデバイスに与えて、遅延時間を表示するメソッドです。</p>

<h3>■ 小問題</h3>

<p>与えられたデバイスの全入力パターンをデバイスに与えて、遅延時間を表示するメソッドtest_circuitを、Simulatorに追加してください。まず与えられたデバイスの出力端子全てにテスタをつなぎます。そして入力端子に対して、全ての入力パターンを生成してデバイスに与えます。</p>

<pre class="codeSample">
def test_circuit(device)
  device.output_count.times do |i|
    device.get_output_terminal(i).connect_input(create_tester("out#{i}"))
  end

  ここを考えてください。
end
</pre>

<h3>解答</h3>

<pre class="codeSample">
module CircuitSimulator
  class Simulator
...
    def test_circuit(device)
      device.output_count.times do |i|
        device.get_output_terminal(i).connect_input(create_tester("out#{i}"))
      end

      CircuitSimulator.permutation(device.input_count) do |input|
        reset
        puts("#{input}")
        device.input_count.times do |i|
          device.get_input_terminal(i).state = input[i]
        end
        start
      end
    end
  end
...
end
</pre>

<p>それでは、遅延時間を測定してみましょう。まずは半加算器です。</p>

<pre class="codeSample">
require 'composite_simulator'

sim = CircuitSimulator::Simulator.new
sim.test_circuit(HalfAdder.new(sim))

[0, 0]
out1: 0 at 10ns.
out0: 0 at 10ns.
[0, 1]
out1: 0 at 10ns.
out0: 1 at 10ns.
out0: 0 at 10ns.
[1, 0]
out1: 0 at 10ns.
out0: 1 at 10ns.
[1, 1]
out1: 1 at 10ns.
out0: 0 at 10ns.
out0: 1 at 10ns.
out1: 0 at 10ns.
</pre>

<p>入力に、1, 1を与えた時に2回出力が行なわれていますね。これは、片方の端子に1が設定されると、出力は0, 1になり、その後、もう一方の端子に1が設定されると、出力が1, 0となるためです。しかも、どうも順番が変なようです。まず、</p>

<pre class="codeSample">
out1: 1 at 10ns.
out0: 0 at 10ns.
</pre>

<p>が表示され、次に、</p>

<pre class="codeSample">
out0: 1 at 10ns.
out1: 0 at 10ns.
</pre>

<p>が表示されていますね。逆ではないのでしょうか？ なぜ、こうなっているのか、分かりますか？ 考えてみてください。</p>
<p>ちょっと難しかったかもしれません。これはSortedListの挙動が原因です。SortedListに既に同じ値のデータが入っている状態で、データを追加すると、その順番は規定されません。なぜなら二分探索では、中点を調べて、それが探索データと等しければ、そこを発見位置として返してしまうからです。ちょっとテストしてみましょう。</p>

<pre class="codeSample">
require 'circuit_simulator'

class TestData
  include Comparable

  def initialize(time, seq)
    @time = time
    @seq = seq
  end

  def &lt;=&gt;(other)
    @time &lt;=&gt; other.time
  end

  attr_reader :time

  def to_s
    "time: #{@time}, seq: #{@seq}"
  end
end

list = CircuitSimulator::SortedList.new
list.put(TestData.new(0, 0))
list.put(TestData.new(0, 1))

puts("#{list.get}")
puts("#{list.get}")
</pre>

<p>これを実行すると、以下のようになります。</p>

<pre class="codeSample">
time: 0, seq: 1
time: 0, seq: 0
</pre>

<p>順番が入れ替わっていますね。2つ目のデータを挿入する際、二分探索で、最初のデータが発見され、その前に挿入するため、このように順番が逆になるわけです。もしも同値のデータがある場合には、その右端に挿入するように、SortedListを変更することにしましょう。</p>

<p class="codeSample">
Q: やっと完成かと思っていたら、また問題が見つかってしまいましたね。<br/>
A: そうです。プログラミングというのは、最後の最後まで、何が起きるか分かりません。それがプログラミングの難しいところでもあり、楽しいところでもあるのです。<br/>
Q: 納期が決まっていたら、楽しんでばかりもいられないです...<br/>
A: そうですね。でも、こればっかりは仕方がありません。完璧な設計など不可能なのです。少しでも、こうしたことが起きることを防ぐには、開発の早い段階から、プログラムを徹底的にテストし続けることです。もしも、SortedListを、もっと徹底的にテストしていたら、今回の問題を予見できていたかもしれませんよ。<br/>
Q: あと、同じ時刻に入力が行われているのであれば、そもそも2回表示が行われるのは、おかしいのではないですか？<br/>
A: 確かにそうです。同一時刻の事象については最終結果のみを返すようにするというのも、1つの考えです。でも、今回の表示は、順番が狂っている点はともかく、2回表示される点は、ある意味正しいのですよ。<br/>
Q: というと？<br/>
A: 実際の回路では、2つの入力のタイミングを完璧に合わせることは不可能で、必ずズレがあります。なので、実際には、このように出力が、一瞬あばれる状況が起きているのです。これはタイミングチャートで見た時、極く一瞬、値が変化することから縦線のように見えるので「ヒゲ」と呼ばれることがあります。これは、思わぬ回路の誤動作の原因となることもあるので、シミュレータで事前に発見できるのは、ありがたいことでしょう。今回は複数の表示が行われる点については、そのままにすることにします。<br/>
</p>

<pre class="codeSample">
83     def put(data)
84       idx = bsearch(data, @table)
85       if idx &lt; 0
86         idx = -idx - 1   # 挿入点
87       else
88         while @table[idx] == data
89           idx = idx + 1
90           break if idx &gt;= @table.size
91         end
92       end
93 
94       @table.insert(idx, data)
95     end
96   end
</pre>

<p>88行目：データが見つかった場合には、データが等しくなくなるか、領域外に出るまで、インデックスを増やすようにしています。</p>

<p>もう一度、SortedListをテストしてみましょう。並べ替えの機能自体が壊れていないかどうかも確認するため、データを増やしています。</p>

<pre class="codeSample">
...
list = CircuitSimulator::SortedList.new
list.put(TestData.new(1, 1))
list.put(TestData.new(0, 0))
list.put(TestData.new(1, 0))
list.put(TestData.new(0, 1))

puts("#{list.get}")
puts("#{list.get}")
puts("#{list.get}")
puts("#{list.get}")
puts("#{list.get}")
</pre>

<p>結果は以下のようになりました。</p>

<pre class="codeSample">
time: 0, seq: 0
time: 0, seq: 1
time: 1, seq: 1
time: 1, seq: 0
...空行...
</pre>

<p>ちゃんと順番通りに並び、時刻が同じ場合には、挿入順になっていますね(time = 1の場合は、わざとseqの順序を逆にしてあります)。データが無い時には、nilが返って空行が出力されていることが分かります。これを使って、もう一度半加算器をテストすると以下のようになります。</p>

<pre class="codeSample">
[0, 0]
out1: 0 at 10ns.
out0: 0 at 10ns.
[0, 1]
out1: 0 at 10ns.
out0: 0 at 10ns.
out0: 1 at 10ns.
[1, 0]
out1: 0 at 10ns.
out0: 1 at 10ns.
[1, 1]
out1: 0 at 10ns.
out0: 1 at 10ns.
out1: 1 at 10ns.
out0: 0 at 10ns.
</pre>

<p>今度は、正しい順番で表示されました。</p>

<h3>■ 小問題</h3>

<p>全加算器、4ビット加算器の遅延時間を調べ、データによって遅延時間が異なることを確認し、最悪値を調べてください。</p>

<h3>解答</h3>

<pre class="codeSample">
require 'composite_simulator'

sim = CircuitSimulator::Simulator.new
sim.test_circuit(FullAdder.new(sim))

(sample15/FourBitAdderTest.rb)
require 'composite_simulator'

sim = CircuitSimulator::Simulator.new
sim.test_circuit(FourBitAdder.new(sim))
</pre>

<p>全加算器の最悪ケースは以下の通り(複数あるうちの1つ)：</p>

<pre class="codeSample">
[0, 1, 1]
out0: 1 at 10ns.
out1: 0 at 20ns.
out0: 0 at 20ns.
out1: 1 at 30ns.
</pre>

<p>4ビット加算器の最悪ケースは以下の通り(複数あるうちの1つ)：</p>

<pre class="codeSample">
[1, 1, 0, 1, 0, 1, 0, 1]
out0: 1 at 20ns.
out0: 0 at 20ns.
out1: 0 at 20ns.
out1: 1 at 20ns.
out2: 0 at 20ns.
out2: 1 at 20ns.
out4: 0 at 20ns.
out3: 0 at 20ns.
out3: 1 at 20ns.
out1: 0 at 30ns.
out2: 0 at 50ns.
out3: 0 at 70ns.
out4: 1 at 80ns.
</pre>

<p class="codeSample">
Q: 全加算器の最悪値が30nsなので、それを4つ使った4ビット加算器の最悪値は、30ns x 4 = 120nsかと思っていました。<br/>
A: なるほど。そのように単純にいかないので、シミュレータに価値があるわけです。例えば最下位桁の全加算器のキャリー入力は0ですね。全加算器のキャリー入力が0の場合の最悪値を調べてみてください。<br/>
Q: あ、キャリー入力が0なら、20nsですね。<br/>
A: そうです。各部にテスタを入れて、回路図と見比べてみて、なぜ80nsになるのか調べてみてください。<br/>
</p>

<hr/>
<p>
  <a href="http://validator.w3.org/check?uri=referer">
    <img src="http://www.w3.org/Icons/valid-xhtml10"
         alt="Valid XHTML 1.0 Strict" height="31" width="88" />
  </a>
</p>
<p>　<a href="mailto:ruimo@ruimo.com">ご感想をお聞かせください(ruimo@ruimo.com)。なお、誠に勝手ながら、HTMLメールはサーバーで全て削除されますので、テキストメールでお願いいたします。</a>
</p>
<p>　<a href="..">書きもののページへ</a></p>
<p>　<a href="../..">トップページへ</a></p>

    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
    <script type="text/javascript">
      _uacct = "UA-2112066-1";
      urchinTracker();
    </script>
</body>
</html>

